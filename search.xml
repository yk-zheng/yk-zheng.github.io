<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第一篇博客</title>
    <url>/2020/04/13/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>@<a href="欢迎来到我的博客">TOC</a></p>
<ul>
<li>仅记录下第一篇博客文章，其实一直以来都想写搭建自己博客，可是迟迟未能动手，各种原因吧，各种忙碌，但是其实很多时候都是借口，因为时间挤挤总是有的，主要是自己眼高手低加上懒，趁着这次机会就搭建了自己的博客平台，写了第一个博客，希望以后自己能好好利用这个平台来记录自己的学习和日常生活。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>加解密算法</title>
    <url>/2020/04/15/%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="AES加密算法"><a href="#AES加密算法" class="headerlink" title="AES加密算法"></a><center>AES加密算法</center></h1><h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>​    AES加解密算法为最常见的对称加密算法。</p>
<p>​    对称加密算法：加密和解密用相同的密钥。具体的加解密流程如下图</p>
<p><img src="E:%5C%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%5CweixinobU7Vjp1oTYyUWhJRol-KkRVdRPw%5C9f58a51e908a4b3aa3ee02a9bdf2a968%5Cclipboard.png" alt="img"></p>
<h2 id="各部分的作用以及含义："><a href="#各部分的作用以及含义：" class="headerlink" title="各部分的作用以及含义："></a>各部分的作用以及含义：</h2><h3 id="1-明文"><a href="#1-明文" class="headerlink" title="1.明文"></a>1.明文</h3><p>​    没有经过加密的数据  </p>
<h3 id="2-密钥K"><a href="#2-密钥K" class="headerlink" title="2.密钥K"></a>2.密钥K</h3><p>​    用来加密明文的密码，在对称加密算法中，加密和解密的密钥是相同的。密钥为接收方与发送方协商产生，但不可以直接在网络上传输，否则会导致密钥泄露，通常是经过非对称加密算法加密密钥，然后再通过网络传输给对方，或者直接面对面商量密钥。密钥是绝对不可以泄露的，否则会被攻击者还原密文，窃取机密数据。</p>
<h3 id="3-AES加密函数"><a href="#3-AES加密函数" class="headerlink" title="3.AES加密函数"></a>3.AES加密函数</h3><p>​    设AES加密函数为E，则C = E（K，P）其中P为明文，K为密钥，C为密文 。也就是说，把明文P和密钥k作为加密函数的参数输入，则加密函数E会输出密文C。</p>
<h3 id="4-密文C"><a href="#4-密文C" class="headerlink" title="4.密文C"></a>4.密文C</h3><p>​    经加密函数处理后的数据  </p>
<h3 id="5-AES解密函数"><a href="#5-AES解密函数" class="headerlink" title="5.AES解密函数"></a>5.AES解密函数</h3><p>​    设AES解密函数为D，则P = D（K，C）其中P为明文，K为密钥，C为密文。也就是说，把密文C和密钥K作为解密函数的参数输入，则解密函数会输出明文P。 </p>
<h2 id="对称加密和非对称加密的区别："><a href="#对称加密和非对称加密的区别：" class="headerlink" title="对称加密和非对称加密的区别："></a>对称加密和非对称加密的区别：</h2><h3 id="1-对称加密算法"><a href="#1-对称加密算法" class="headerlink" title="1.对称加密算法"></a>1.对称加密算法</h3><p>​     加密和解密用到的密钥是相同的，这种加密方式加密速度非常快，适合经常发生数据的场合。缺点是密钥的传输比较麻烦。</p>
<h3 id="2-非对称密钥加密算法"><a href="#2-非对称密钥加密算法" class="headerlink" title="2.非对称密钥加密算法"></a>2.非对称密钥加密算法</h3><p>​    加密和解密用的密钥是不同的，这种加密方式是用数学上的难解问题构造的，通常加密解密的速度比较慢，适合偶尔发送数据的场合。优点是密钥传输方便。常见的非对称加密算法为RSA，ECC和ELGamal。</p>
<p>​    实际中，一般是通过RSA加密AES的密钥，传输到接收方，接受方解密得到AES密钥，然后发送方和接受方用AES密钥来通信。</p>
<h2 id="AES的基本结构："><a href="#AES的基本结构：" class="headerlink" title="AES的基本结构："></a>AES的基本结构：</h2><p>​    AES为分组密码，分组密码也就是把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文，在AES标准规范中，分组长度只能说128位，也就是说，每个分组位16个字节（每个字节8位）。密钥的长度可以使用128位，192位或者是256位。密钥的长度不同，推荐加密的轮数也不同。如下表所示：<img src="E:%5C%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%5CweixinobU7Vjp1oTYyUWhJRol-KkRVdRPw%5Cf372ea4f9f0a49c69e562cdb0c65ad1d%5Cclipboard.png" alt="img"></p>
<p>​    下面实现AES-128，也就是密钥长度为128位，加密轮数为10轮。</p>
<p>​    上面说到，AES的加密公式为 C = E （K，P），在加密函数E中，会执行一个轮函数，并且会执行10次这个轮函数，这个轮函数的前9次执行的操作是一样的，只有第10次有所不同，也就是说，一个明文分组会被加密10轮。AES的核心就是实现一轮中的所有操作。</p>
<p>​    AES的处理单位是字节，128位的输入明文分组P和输入密钥K都被分成16个字节，分别记为P=P0 … P15和K =K0 K1 … K15。例如明文分组P = abcdefghijklmnop,其中的字符a对应P0，p对应P15，一般的，明文分组用字节为单位的正方形矩阵描述，称为状态矩阵。在算法的每一轮中，状态矩阵的内容不断发生变化，最后的结果作为密文输出。该矩阵中字节的排列顺序为从上到下，从左到右依次排列，如下图所示：</p>
<p><img src="E:%5C%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%5CweixinobU7Vjp1oTYyUWhJRol-KkRVdRPw%5C8570dee39bc34b888d5d87dd93e5cbca%5Cclipboard.png" alt="img"></p>
<p>​    以刚才的例子为例假设现在的明文分组P为“abcdefghijklmnop”，则对应上面的生成状态矩阵图如下：</p>
<p><img src="E:%5C%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%5CweixinobU7Vjp1oTYyUWhJRol-KkRVdRPw%5C8f5d2eee802e46e8bf5c7a0f60161fc9%5Cclipboard.png" alt="img"></p>
<p>​    上图中0x61为字符a的十六进制表示，可以看出，明文经过AES加密后，已经面目全非。</p>
<p>​    类似的，128位密钥也是用字节为单位的矩阵表示，矩阵的每一列被成为1个32位比特字。通过密钥编排函数该密钥矩阵被拓展成为一个44个字节组成的序列W[0],W[1]，…，W[43]，该序列的前4个元素W[0]，W[1]，W[2]，W[3]，是原始密钥，用于加密算法中初始密钥加（下面还会写到）；后面40个字节分为10组，每组4个字（128比特）分别用于10轮加密运算中的轮密钥加，如下图所示：<img src="E:%5C%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%5CweixinobU7Vjp1oTYyUWhJRol-KkRVdRPw%5Cecff6b7b9e344e7189aadee771340839%5Cclipboard.png" alt="img"></p>
<p>​    上图中，设K = “abcdefghiklmnop”，则K0 = a，K15 = p，W[0]=K0 K1 K2 K3 =”abcd”。</p>
<p>​    AES的整体结构如下图所示，其中W[0,3]是指W[0],W[1],W[2]和W[3]串联组成的128位密钥。加密的第1轮到第9轮的轮函数一样，包括4个操作：字节代换，行位移，列混合和轮密钥加，最后一轮迭代不执行列混合。另外，在第一轮迭代之前，先将明文和原始密钥进行一次异或加密操作。<img src="E:%5C%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%5CweixinobU7Vjp1oTYyUWhJRol-KkRVdRPw%5C35b74ad72fbf48f5863169de3ed4b34b%5Cclipboard.png" alt="img"></p>
<p>​    上图也展示了AES加密过程，解密过程仍为10轮，每一轮的操作是加密操作的逆操作。由于AES的4个轮操作都是可逆的，因此，解密操作的一轮就是顺序执行逆行移位，逆字节代换，轮密钥加和逆列混合。同加解密操作类似，最后一轮不执行逆列混合，在1轮解密之前，要执行1次密钥加操</p>
<h2 id="AES中一轮的4个操作阶段："><a href="#AES中一轮的4个操作阶段：" class="headerlink" title="AES中一轮的4个操作阶段："></a>AES中一轮的4个操作阶段：</h2><ul>
<li><h3 id="字节代替"><a href="#字节代替" class="headerlink" title="字节代替"></a>字节代替</h3></li>
</ul>
<ol>
<li><p>字节代换操作</p>
<p>AES的字节代换其实就是一个简单的查表操作。AES定义了一个S盒和一个逆S盒。</p>
<p>AES的S盒：<img src="E:%5C%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%5CweixinobU7Vjp1oTYyUWhJRol-KkRVdRPw%5Ccc08fe9e35d04d31afdd85f5fa4f4224%5Cclipboard.png" alt="img"></p>
<p>状态矩阵中的元素按照下面的方式映射为一个新的字节：把该字节的高4位作为行值，低四位作为列值，取出S盒或者逆S盒中对应的行的元素作为输出。例如，加密时，输出的字节S1作为0x12，则查S盒的第0x01行和0x02列，得到值0xc9,然后替换S1原有的0x12为0xc9。状态矩阵经字节代换后的图如下： (第二个字符0xAB查表后应该是转换成0x62)</p>
<p><img src="E:%5C%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%5CweixinobU7Vjp1oTYyUWhJRol-KkRVdRPw%5C6e30c99f2afa41279efba27f2d09c169%5Cclipboard.png" alt="img"></p>
</li>
<li><p>字节代换逆操作</p>
</li>
</ol>
<p>​    逆字节代换也就是S盒来变换，逆S盒如下：</p>
<p><img src="E:%5C%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%5CweixinobU7Vjp1oTYyUWhJRol-KkRVdRPw%5C1d6711d7ee5f4d02a2586a3a47a5cc75%5Cclipboard.png" alt="img"></p>
<ul>
<li><h3 id="行移位"><a href="#行移位" class="headerlink" title="行移位"></a>行移位</h3></li>
</ul>
<ol>
<li><p>行移位操作 </p>
<p>​    行移位是一个简单的左循环移位操作。当密钥长度为128比特时，状态矩阵的第0行左移0个字节，第1行左移1字节，第2行左移2字节，第3行左移3字节，如下图所示</p>
<p><img src="E:%5C%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%5CweixinobU7Vjp1oTYyUWhJRol-KkRVdRPw%5C416b6659cc9948d992545e2f01cebfbc%5Cclipboard.png" alt="img"></p>
</li>
<li><p>行移位的逆变换</p>
<p>​    行移位的逆变换是将状态矩阵中的每一行执行相反的只为操作，例如AES-128中，状态矩阵的第0行右移0字节，第一行右移1字节，第二行右移2字节，第三行右移3字节。 </p>
</li>
</ol>
<ul>
<li><h3 id="列混合"><a href="#列混合" class="headerlink" title="列混合"></a>列混合</h3></li>
</ul>
<ol>
<li><p>列混合操作 </p>
<p>​    列混合变换是通过矩阵相乘来实现的，经行移位后的状态矩阵与固定的矩阵相乘，得到混淆后的状态矩阵，如下图的公式所示：</p>
<p><img src="E:%5C%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%5CweixinobU7Vjp1oTYyUWhJRol-KkRVdRPw%5C0361b0d00fdf4b6a981b8a476953d2d9%5Cclipboard.png" alt="img"></p>
<p>​    状态矩阵中的第j列(0 ≤j≤3)的列混合可以表示为下图所示：  </p>
<p><img src="E:%5C%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%5CweixinobU7Vjp1oTYyUWhJRol-KkRVdRPw%5C92c2254484e04b5285a9e3516f3eccbd%5Cclipboard.png" alt="img"></p>
<p>​    其中，矩阵元素的乘法和加法都是定义在基于GF(2^8)上的二元运算,并不是通常意义上的乘法和加法。这里涉及到一些信息安全上的数学知识，不过不懂这些知识也行。其实这种二元运算的加法等价于两个字节的异或，乘法则复杂一点。对于一个8位的二进制数来说，使用域上的乘法乘以(00000010)等价于左移1位(低位补0)后，再根据情况同(00011011)进行异或运算，设S1 = (a7 a6 a5 a4 a3 a2 a1 a0)，刚0x02 * S1如下图所示：</p>
<p><img src="E:%5C%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%5CweixinobU7Vjp1oTYyUWhJRol-KkRVdRPw%5Ccb7230ff81a641b0bd1298fc474cc896%5Cclipboard.png" alt="img"></p>
<p>​    也就是说，如果a7为1，则进行异或运算，否则不进行。 </p>
<p>类似地，乘以(00000100)可以拆分成两次乘以(00000010)的运算：</p>
<p><img src="E:%5C%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%5CweixinobU7Vjp1oTYyUWhJRol-KkRVdRPw%5Cf46e43af43b542d3aa4334744b8a90c3%5Cclipboard.png" alt="img"></p>
<p>乘以(0000 0011)可以拆分成先分别乘以(0000 0001)和(0000 0010)，再将两个乘积异或：</p>
<p><img src="E:%5C%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%5CweixinobU7Vjp1oTYyUWhJRol-KkRVdRPw%5C967322e1ead34f9898c7de1087fe2f97%5Cclipboard.png" alt="img"></p>
<p> 因此，我们只需要实现乘以2的函数，其他数值的乘法都可以通过组合来实现。 </p>
<p>下面举个具体的例子,输入的状态矩阵如下：</p>
<p><img src="E:%5C%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%5CweixinobU7Vjp1oTYyUWhJRol-KkRVdRPw%5Ca76aaf68f01b48f7ba135501ff07406a%5Cclipboard.png" alt="img"></p>
</li>
<li><p>列混合逆运算</p>
<p>逆向列混合变换可由下图的矩阵乘法定义：</p>
</li>
</ol>
<p><img src="E:%5C%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%5CweixinobU7Vjp1oTYyUWhJRol-KkRVdRPw%5Cc499c38e1b954fa2bc6bc7be1f614e2d%5Cclipboard.png" alt="img"></p>
<p>​    可以验证，逆变换矩阵同正变换矩阵的乘积恰好为单位矩阵。</p>
<ul>
<li><h3 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h3><p>轮密钥加是将128位轮密钥Ki同状态矩阵中的数据进行逐位异或操作，如下图所示。其中，密钥Ki中每个字W[4i],W[4i+1],W[4i+2],W[4i+3]为32位比特字，包含4个字节，他们的生成算法下面在下面介绍。轮密钥加过程可以看成是字逐位异或的结果，也可以看成字节级别或者位级别的操作。也就是说，可以看成S0 S1 S2 S3 组成的32位字与W[4i]的异或运算。</p>
</li>
</ul>
<p><img src="E:%5C%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%5CweixinobU7Vjp1oTYyUWhJRol-KkRVdRPw%5Cc7ce299f0cea4ab38924df69025fcd20%5Cclipboard.png" alt="img"></p>
<p>​        轮密钥加的逆运算同正向的轮密钥加运算完全一致，这是因为异或的逆操作是其自身。轮密钥加非常简单，但却能够影响S数组中的每一位</p>
<ol>
<li><p>密钥拓展</p>
<p>AES首先将初始密钥输入到一个4*4的状态矩阵中，如下图所示 </p>
</li>
</ol>
<p><img src="E:%5C%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%5CweixinobU7Vjp1oTYyUWhJRol-KkRVdRPw%5C82ee701b0ac840028401e2d3d337ff05%5Cclipboard.png" alt="img"></p>
<pre><code>这个4*4矩阵的每一列的4个字节组成一个字，矩阵4列的4个字依次命名为W[0]、W[1]、W[2]和W[3]，它们构成一个以字为单位的数组W。例如，设密钥K为”abcdefghijklmnop”,则K0 = ‘a’,K1 = ‘b’, K2 = ‘c’,K3 = ‘d’,W[0] = “abcd”。 </code></pre><p>​    接着，对W数组扩充40个新列，构成总共44列的扩展密钥数组。新列以如下的递归方式产生： </p>
<p>​        1.如果i不是4的倍数，那么第i列由如下等式确定： </p>
<p>​            W[i]=W[i-4]⨁W[i-1] </p>
<p>​        2.如果i是4的倍数，那么第i列由如下等式确定： </p>
<p>​            W[i]=W[i-4]⨁T(W[i-1]) </p>
<p>​            其中，T是一个有点复杂的函数。 </p>
<p>​    函数T由3部分组成：字循环、字节代换和轮常量异或，这3部分的作用分别如下。 </p>
<p>a.字循环：将1个字中的4个字节循环左移1个字节。即将输入字[b0, b1, b2, b3]变换成    [b1,b2,b3,b0]。 </p>
<p>b.字节代换：对字循环的结果使用S盒进行字节代换。 </p>
<p>c.轮常量异或：将前两步的结果同轮常量Rcon[j]进行异或，其中j表示轮数。 </p>
<p>​    轮常量Rcon[j]是一个字，其值见下表。</p>
<p><img src="E:%5C%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%5CweixinobU7Vjp1oTYyUWhJRol-KkRVdRPw%5C2195e47d744145f68b630bd46f7d8420%5Cclipboard.png" alt="img"></p>
<p> 下面举个例子： </p>
<p>设初始的128位密钥为： </p>
<p>3C A1 0B 21 57 F0 19 16 90 2E 13 80 AC C1 07 BD </p>
<p>那么4个初始值为： </p>
<p>W[0] = 3C A1 0B 21 </p>
<p>W[1] = 57 F0 19 16 </p>
<p>W[2] = 90 2E 13 80 </p>
<p>W[3] = AC C1 07 BD </p>
<p>下面求扩展的第1轮的子密钥(W[4],W[5],W[6],W[7])。 </p>
<p>由于4是4的倍数，所以： </p>
<p>W[4] = W[0] ⨁ T(W[3]) </p>
<p>T(W[3])的计算步骤如下： </p>
<p>\1. 循环地将W[3]的元素移位：AC C1 07 BD变成C1 07 BD AC; </p>
<p>\2. 将 C1 07 BD AC 作为S盒的输入，输出为78 C5 7A 91; </p>
<p>\3. 将78 C5 7A 91与第一轮轮常量Rcon[1]进行异或运算，将得到79 C5 7A 91，因此，T(W[3])=79 C5 7A 91，故 </p>
<pre><code>W[4] = 3C A1 0B 21 ⨁ 79 C5 7A 91 = 45 64 71 B0 </code></pre><p>其余的3个子密钥段的计算如下： </p>
<p>W[5] = W[1] ⨁ W[4] = 57 F0 19 16 ⨁ 45 64 71 B0 = 12 94 68 A6 </p>
<p>W[6] = W[2] ⨁ W[5] =90 2E 13 80 ⨁ 12 94 68 A6 = 82 BA 7B 26 </p>
<p>W[7] = W[3] ⨁ W[6] = AC C1 07 BD ⨁ 82 BA 7B 26 = 2E 7B 7C 9B </p>
<p>所以，第一轮的密钥为 45 64 71 B0 12 94 68 A6 82 BA 7B 26 2E 7B 7C 9B。</p>
<h2 id="AES解密"><a href="#AES解密" class="headerlink" title="AES解密"></a>AES解密</h2><p> 在文章开始的图中，有AES解密的流程图，可以对应那个流程图来进行解密。下面介绍的是另一种等价的解密模式，流程图如下图所示。这种等价的解密模式使得解密过程各个变换的使用顺序同加密过程的顺序一致，只是用逆变换取代原来的变换</p>
<p><img src="E:%5C%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%5CweixinobU7Vjp1oTYyUWhJRol-KkRVdRPw%5Cf71da2bc06964551ac26d7f36f80f9fe%5Cclipboard.png" alt="img"></p>
<h6 id="转自文章https-blog-csdn-net-zxh2075-article-details-80630296"><a href="#转自文章https-blog-csdn-net-zxh2075-article-details-80630296" class="headerlink" title="转自文章https://blog.csdn.net/zxh2075/article/details/80630296"></a>转自文章<a href="https://blog.csdn.net/zxh2075/article/details/80630296" target="_blank" rel="noopener">https://blog.csdn.net/zxh2075/article/details/80630296</a></h6>]]></content>
      <tags>
        <tag>-密码学</tag>
      </tags>
  </entry>
</search>
